      - name: Extract Manifest Information
        id: extract_info
        env:
          FILE: ${{ github.event.inputs.FILE }}
          DYNAMIC_REPO_INPUT: ${{ github.event.inputs.DYNAMIC_REPO }}
        run: |
          set -e
          cd "$GITHUB_WORKSPACE"

          echo "Extract Manifest"

          # Normalize File Name
          if [[ "$FILE" =~ ^(.+)_([a-zA-Z])$ ]]; then
            FILE_CONF="${BASH_REMATCH[1]}"
          else
            FILE_CONF="$FILE"
          fi
          
          FILE_BASE=$(echo "$FILE_CONF" | sed -E '
            s/_aosp/(AOSP)/g;
            s/_([a-zA-Z0-9])/\U\1/g;
            s/^oneplus/OnePlus/;
            s/^realme/RealME/;
            s/^oppo/OPPO/
          ')

          mkdir -p ".repo/manifests_fallback"
          XML_PATH=".repo/manifests_fallback/${FILE}.xml"
          README_PATH=".repo/manifests_fallback/README.md"

          echo "FILE=$FILE"
          echo "FILE_CONF=$FILE_CONF"
          echo "FILE_BASE=$FILE_BASE"

          {
            echo "FILE_CONF=$FILE_CONF"
            echo "FILE_BASE=$FILE_BASE"
            } >> "$GITHUB_ENV"
          
            # Repository Priority:
            # 1. OnePlusOSS/kernel_manifest
            # 2. OnePlusOSS/Kernel_Manifest_Appendix
            # 3. User Defined Dynamic Repo
          
            declare -A REPOS
          
            REPOS["OnePlusOSS"]="OnePlusOSS|kernel_manifest"
            REPOS["Appendix"]="OnePlusOSS|Kernel_Manifest_Appendix"
          
            # Only Register Dynamic Repository if Input is Not Empty
            if [[ -n "$DYNAMIC_REPO_INPUT" ]]; then
              # Remove https://github.com/ if User Pasted full URL
              DYNAMIC_REPO_INPUT="${DYNAMIC_REPO_INPUT#https://github.com/}"
              DYNAMIC_REPO_INPUT="${DYNAMIC_REPO_INPUT%/}"
              
              if [[ "$DYNAMIC_REPO_INPUT" =~ ^[^/]+/[^/]+$ ]]; then
                echo "Dynamic Repository Detected: $DYNAMIC_REPO_INPUT"
                REPOS["Dynamic"]="${DYNAMIC_REPO_INPUT}|kernel_manifest"
              else
                echo "WARNING: Invalid Dynamic Repository Format"
                echo "Expected: OWNER/REPO"
                echo "Provided: $DYNAMIC_REPO_INPUT"
                echo "Skipping Dynamic Repository Instead of Failing"
              fi
            fi
                        
            FOUND_REPO=""
            FOUND_REPO_NAME=""
            FOUND_BRANCH=""

            check_repo() {
              local ENTRY="$1"
              [[ -z "$ENTRY" ]] && return 1
                     
              local OWNER=${ENTRY%%|*}
              local REPO_NAME=${ENTRY##*|}

              echo ""
              echo ">>> Checking ${OWNER}/${REPO_NAME}"
            
            local API_URL="https://api.github.com/repos/${OWNER}/${REPO_NAME}"

            # Fetch Branches Safely with GitHub Token
            local BRANCHES
            BRANCHES=$(curl -fsSL -H "Authorization: token $GH_TOKEN" "${API_URL}/branches" \
              | jq -r '.[]?.name' 2>/dev/null || true)

            if [[ -z "$BRANCHES" ]]; then
              echo "Failed to Retrieve Branches for ${OWNER}/${REPO_NAME}"
              return 1
            fi
            
            for BRANCH in $BRANCHES; do
              echo "  → Trying Branch: $BRANCH"
              
              XML_URL="https://raw.githubusercontent.com/${OWNER}/${REPO_NAME}/${BRANCH}/${FILE}.xml"
              README_URL="https://raw.githubusercontent.com/${OWNER}/${REPO_NAME}/${BRANCH}/README.md"

              if curl -sf -H "Authorization: token $GH_TOKEN" --head "$XML_URL" >/dev/null; then
                echo "Found ${FILE}.xml in ${OWNER}/${REPO_NAME} (Branch: $BRANCH)"

                # Download XML and README using GitHub Token
                curl -fsSL -H "Authorization: token $GH_TOKEN" -o "$XML_PATH" "$XML_URL"
                curl -fsSL -H "Authorization: token $GH_TOKEN" -o "$README_PATH" "$README_URL" || true

                FOUND_REPO="$OWNER"
                FOUND_REPO_NAME="$REPO_NAME"
                FOUND_BRANCH="$BRANCH"

                return 0
              fi
            done

            echo "Not Found in ${OWNER}/${REPO_NAME}"
            return 1
          }

          # Ordered Search
          for key in OnePlusOSS Appendix Dynamic; do
            if [[ -n "${REPOS[$key]}" ]]; then
              if check_repo "${REPOS[$key]}"; then
                break
              fi
            fi
          done

          # Final Validation
          if [[ -z "$FOUND_REPO" || ! -s "$XML_PATH" ]]; then
            echo ""
            echo "ERROR: ${FILE}.xml Not Found in Any Configured Repository"
            exit 9
          fi

          echo ""
          echo "============= Manifest Located ============="
          echo "Repository : ${FOUND_REPO}/${FOUND_REPO_NAME}"
          echo "Branch     : ${FOUND_BRANCH}"
          echo "============================================"

          {
            echo "MANIFEST_REPO=$FOUND_REPO"
            echo "MANIFEST_REPO_NAME=$FOUND_REPO_NAME"
            echo "MANIFEST_BRANCH=$FOUND_BRANCH"
          } >> "$GITHUB_ENV"
                 
          # Parse Revision String

          echo "Parsing Manifest"

          REVISION=$(grep -oP '<project[^>]+revision="\K[^"]+' "$XML_PATH" | head -n1 || true)

          if [[ -z "${REVISION:-}" ]]; then
            echo "ERROR: No revision string found in XML"
            exit 1
          fi

          echo "REVISION=$REVISION"
          echo "Parsing CPU & Android Version..."

          # Extract CPU
          CPU=$(echo "$REVISION" | sed -E 's#^(oneplus|realme|oppo)/([^_]+).*#\2#')

          # Extract Android Version (e.g. 13.0 or 14.0.1)
          ANDROID_VERSION=$(echo "$REVISION" | grep -oE '[0-9]{1,2}\.[0-9]{1,2}(\.[0-9]{1,2})?' | head -n1 || true)

          if [[ -z "$CPU" || -z "$ANDROID_VERSION" ]]; then
            echo "ERROR: Failed to extract CPU or Android version"
            exit 1
          fi

          ANDROID_SHORT_VERSION="${ANDROID_VERSION%%.*}"

          echo "CPU=$CPU"
          echo "ANDROID_VERSION=$ANDROID_VERSION"
          echo "ANDROID_SHORT_VERSION=$ANDROID_SHORT_VERSION"

          {
            echo "CPU=$CPU"
            echo "ANDROID_VERSION=$ANDROID_VERSION"
            echo "ANDROID_SHORT_VERSION=$ANDROID_SHORT_VERSION"
          } >> "$GITHUB_ENV"

          # Parse README to Obtain CPUD & Build Method
          echo "Parsing README"

          if [[ -s "$README_PATH" ]]; then
            BUILD_LINE=$(grep -m1 'oplus_build_kernel.sh' "$README_PATH" || true)

            if [[ -n "$BUILD_LINE" ]]; then
              # More reliable extraction: pull last two arguments
              CPUD=$(awk '{print $(NF-1)}' <<< "$BUILD_LINE")
              BUILD_METHOD=$(awk '{print $NF}' <<< "$BUILD_LINE")

              echo "CPUD=$CPUD"
              echo "BUILD_METHOD=$BUILD_METHOD"

              {
                echo "CPUD=$CPUD"
                echo "BUILD_METHOD=$BUILD_METHOD"
              } >> "$GITHUB_ENV"
            else
              echo "WARNING: Build command not found in README.md"
            fi
          else
            echo "WARNING: README missing or empty"
          fi

          # Parse XML to Obtain PATH_2
          echo "Searching PATH_2"

          PATH_2=""

          if [[ "$CPU" == sm* ]]; then
            COUNT_MATCH=0

            while IFS= read -r LINE; do
              REV=$(grep -oP 'revision="\K[^"]+' <<< "$LINE" || true)
              PATH_VAL=$(grep -oP 'path="\K[^"]+' <<< "$LINE" || true)

              [[ -z "$REV" || -z "$PATH_VAL" ]] && continue

              if [[ "$REV" =~ ^(oneplus|oppo)/ ]] || [[ "$REV" == "master" ]]; then
                COUNT_MATCH=$((COUNT_MATCH + 1))

                if [[ $COUNT_MATCH -eq 2 ]]; then
                  PATH_2="${PATH_VAL#kernel_platform/}"
                  break
                fi
              fi
            done < <(grep "<project " "$XML_PATH" || true)
          fi

          if [[ -n "$PATH_2" ]]; then
            echo "PATH_2=$PATH_2"
            echo "PATH_2=$PATH_2" >> "$GITHUB_ENV"
          else
            echo "No valid PATH_2 found (may not apply to this device)"
          fi

          # Export Combined Output Value
          echo "value=${FILE_BASE}_Android${ANDROID_VERSION}" >> "$GITHUB_OUTPUT"

          echo "Manifest Parsing Complete"    
          
      - name: Debug – Show Selected Inputs
        shell: bash
        run: |
          set -euo pipefail

          echo "--- DEBUG INPUTS ---"

           # Helper: Print Unicode Codepoints
           print_unicode() {
             local LABEL="$1"
             local VALUE="$2"

             echo -n "$LABEL Unicode: "

             python3 <<EOF
          import unicodedata
          value = """$VALUE"""
          output = []
          for c in value:
              code = f"U+{ord(c):04X}"
              if c.isspace() or unicodedata.category(c) == "Cf":
                  output.append(f"\033[31m{code}\033[0m")
              else:
                  output.append(code)
          print(" ".join(output))
          EOF
                echo
              }

              # ENV Variables (Parsed from Manifest)
              
              echo "--- Manifest Parsed Values ---"
              echo "CPU               : ${CPU:-<empty>}"
              echo "CPUD              : ${CPUD:-<empty>}"
              echo "ANDROID_VERSION   : ${ANDROID_VERSION:-<empty>}"
              echo "BUILD_METHOD      : ${BUILD_METHOD:-<empty>}"

              # GitHub Action Inputs
              
              echo "--- GitHub Inputs ---"
              echo "FILE              : ${{ github.event.inputs.FILE }}"
              echo "KPM               : ${{ github.event.inputs.KPM }}"
              echo "MANAGER_SOURCE    : ${{ github.event.inputs.MANAGER_SOURCE }}"
              echo "SUSFS_META        : ${{ github.event.inputs.SUSFS_META }}"
              echo "KSU_META          : ${{ github.event.inputs.KSU_META }}"
              echo "ZRAM              : ${{ github.event.inputs.ZRAM }}"
              echo "BUILD_TIME        : ${{ github.event.inputs.BUILD_TIME }}"
              echo "SUFFIX            : ${{ github.event.inputs.SUFFIX }}"
              echo "LSM               : ${{ github.event.inputs.LSM }}"
              echo "NETFILTER         : ${{ github.event.inputs.NETFILTER }}"
              echo "BBR_ECN           : ${{ github.event.inputs.BBR_ECN }}"
              echo "SUSFS_DEV         : ${{ github.event.inputs.SUSFS_DEV }}"
              echo "FAST_BUILD        : ${{ github.event.inputs.FAST_BUILD }}"
              echo "SCHED             : ${{ github.event.inputs.SCHED }}"
              echo "UNICODE_BYPASS    : ${{ github.event.inputs.UNICODE_BYPASS }}"
              echo "XUS_FIX           : ${{ github.event.inputs.XUS_FIX }}"

              # Unicode Inspection (Whitespace / Hidden Character Detection)

              print_unicode "BUILD_TIME" "${{ github.event.inputs.BUILD_TIME }}"
              print_unicode "SUFFIX" "${{ github.event.inputs.SUFFIX }}"

      #######################################################################################################################

      - name: Setup Required Packages
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            clang \
            lld \
            ccache \
            build-essential \
            bc \
            git \
            python3 \
            libncurses5-dev \
            libssl-dev \
            libelf-dev \
            libncurses-dev \
            flex \
            bison

      #######################################################################################################################

      - name: Build Kernel (Fast)
        if: ${{ github.event.inputs.FAST_BUILD == 'true' }}
        id: fast_build
        run: |
          cd kernel_workspace/kernel_platform

          # Automatic LLVM IAS Detection 
          if [[ -f ./common/build.config.arm ]] && grep -q '^LLVM_IAS=1' ./common/build.config.arm; then
            USE_LLVM_IAS=true
          else
            USE_LLVM_IAS=false
          fi

          # Locate Clang Prebuilt Bin 
          CLANG_PREBUILT_BIN=""
          for f in ./common/build.config.common ./"$PATH_2"/build.config.common; do
            [[ -f "$f" ]] || continue
            CLANG_PREBUILT_BIN=$(grep '^CLANG_PREBUILT_BIN=' "$f" | cut -d'=' -f2)
            [[ -n "$CLANG_PREBUILT_BIN" ]] && break
          done

          if [[ -z "$CLANG_PREBUILT_BIN" ]]; then
            echo "⚠️ Clang Prebuilt Bin not found; fallback to official build"
            echo "fallback=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # Extract Clang Version
          if [[ "$CLANG_PREBUILT_BIN" =~ (clang-r[0-9a-z]+) ]]; then
            CLANG_VERSION="${BASH_REMATCH[1]}"
          elif [[ -f ./common/build.config.constants ]]; then
            CLANG_VERSION=$(grep '^CLANG_VERSION=' ./common/build.config.constants | cut -d'=' -f2 || true)
          fi

          if [[ -z "$CLANG_VERSION" ]]; then
            echo "⚠️ Cannot detect Clang version; fallback to official build"
            echo "fallback=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # Replace variable in path
          CLANG_PREBUILT_BIN=${CLANG_PREBUILT_BIN/\$\{CLANG_VERSION\}/$CLANG_VERSION}
          CLANG_DIR=$(echo "$CLANG_PREBUILT_BIN" | cut -d'/' -f1)
          CLANG_PATH=$(basename "$(dirname "$CLANG_PREBUILT_BIN")")

          echo "CLANG_VERSION=$CLANG_VERSION"
          echo "CLANG_DIR=$CLANG_DIR"
          echo "CLANG_PATH=$CLANG_PATH"
          echo "USE_LLVM_IAS=$USE_LLVM_IAS"

          # Environment Setup 
          set +u
          source "$GITHUB_WORKSPACE/kernel_workspace/kernel_platform/build/kernel/_setup_env.sh" 2>/dev/null || true
          set -u

          export PATH="$GITHUB_WORKSPACE/kernel_workspace/kernel_platform/$CLANG_PREBUILT_BIN:$PATH"
          export PATH="/usr/lib/ccache:$PATH"
          export HDRINST=:

          if [[ "$ENABLE_RUST" == "true" ]]; then
            export BINDGEN="bindgen"
            export LIBCLANG_PATH="$GITHUB_WORKSPACE/kernel_workspace/kernel_platform/$(dirname "$CLANG_PREBUILT_BIN")/lib"
          fi

          cd ./common

          MAP="-fdebug-prefix-map=${GITHUB_WORKSPACE}=."
          MPMAP="-fmacro-prefix-map=${GITHUB_WORKSPACE}=."
          FPMAP="-ffile-prefix-map=${GITHUB_WORKSPACE}=."

          MAKE_ARGS=(
            LLVM=1
            ARCH=arm64
            CROSS_COMPILE=aarch64-linux-gnu-
            CC="ccache clang"
            HOSTCC="ccache clang"
            LD=ld.lld
            HOSTLD=ld.lld
            PAHOLE=../../prebuilts/kernel-build-tools/linux-x86/bin/pahole
            KCFLAGS+="$MAP $MPMAP $FPMAP"
            KCFLAGS+=-Wno-error
            KCFLAGS+=-D__ANDROID_COMMON_KERNEL__
          )

          [[ "$USE_LLVM_IAS" == "true" ]] && MAKE_ARGS=(LLVM_IAS=1 "${MAKE_ARGS[@]}")
          [[ "$ENABLE_RUST" == "true" ]] && MAKE_ARGS=(RUSTC=../../prebuilts/rust/linux-x86/$RUSTC_VERSION/bin/rustc "${MAKE_ARGS[@]}")

          make O=out "${MAKE_ARGS[@]}" gki_defconfig

          # LTO config based on kernel version
          if [[ "$KERNEL_VERSION" == "5.10" || "$KERNEL_VERSION" == "5.15" ]]; then
            scripts/config --file out/.config -e LTO_CLANG -e LTO_CLANG_THIN -d LTO_CLANG_NONE -d LTO_CLANG_FULL
          elif [[ "$KERNEL_VERSION" == "6.12" ]]; then
            scripts/config --file out/.config -e LTO_CLANG -e LTO_CLANG_NONE -d LTO_CLANG_THIN -d LTO_CLANG_FULL
          fi

          make O=out "${MAKE_ARGS[@]}" olddefconfig
          make -j"$(nproc --all)" O=out "${MAKE_ARGS[@]}"
          ccache -s

      #######################################################################################################################

      - name: Fallback Build (HDRINST + LLVM + lld fix)
        if: ${{ github.event.inputs.FAST_BUILD == 'false' || steps.fast_build.outputs.fallback == 'true' }}
        run: |
          cd kernel_workspace/kernel_platform

          # === Fix HDRINST to avoid install headers error ===
          export HDRINST=:

          # === Ensure Clang + lld are used for host and target ===
          export PATH="$GITHUB_WORKSPACE/kernel_workspace/kernel_platform/prebuilts/clang/host/linux-x86/llvm-rXYZ/bin:$PATH"
          export CC=clang
          export HOSTCC=clang
          export LD=ld.lld
          export HOSTLD=ld.lld

          # Optional: ccache if desired
          export PATH="/usr/lib/ccache:$PATH"

          # === Build kernel in common/out ===
          cd common

          # Remap physical paths to avoid debug file warnings
          MAP="-fdebug-prefix-map=${GITHUB_WORKSPACE}=."
          MPMAP="-fmacro-prefix-map=${GITHUB_WORKSPACE}=."
          FPMAP="-ffile-prefix-map=${GITHUB_WORKSPACE}=."

          MAKE_ARGS=(
            ARCH=arm64
            CROSS_COMPILE=aarch64-linux-gnu-
            CC="$CC"
            HOSTCC="$HOSTCC"
            LD="$LD"
            HOSTLD="$HOSTLD"
            KCFLAGS+="$MAP $MPMAP $FPMAP"
            KCFLAGS+=-Wno-error
            KCFLAGS+=-D__ANDROID_COMMON_KERNEL__
          )

          # Run sub-make safely
          make O=out "${MAKE_ARGS[@]}" gki_defconfig || true
          make -j"$(nproc --all)" O=out "${MAKE_ARGS[@]}" || true

          # Check if Image is generated
          if [ ! -f out/Image ]; then
            echo "❌ Kernel build failed: Image not found" >&2
            exit 1
          fi

          echo "✅ Kernel build completed successfully"
      
      #######################################################################################################################

      - name: Make AnyKernel3
        run: |
          set -euo pipefail

          echo ">> Cloning AnyKernel3 Repository"
          git clone https://github.com/AndreiMikh/AnyKernel3 --depth=1
          rm -rf ./AnyKernel3/.git

          echo ">> Ensuring Final-Image-Find Directory Exists"
          mkdir -p kernel_workspace/kernel_platform/out/Final-Image-Find/

          image_path=""

          # Try to Locate Image in Unified Build Path
          if [ -d "./kernel_workspace/kernel_platform/common/out/" ]; then
            image_path=$(find "./kernel_workspace/kernel_platform/common/out/" -name "Image" | head -n 1)
            if [ -n "$image_path" ]; then
              echo "✅ Unified Path Image Found: $image_path"
            fi
          fi

          # If Not Found, Try Fallback Path
          if [ -z "$image_path" ] && [ -d "./kernel_workspace/kernel_platform/out/" ]; then
            image_path=$(find "./kernel_workspace/kernel_platform/out/" -name "Image" | head -n 1)
            if [ -n "$image_path" ]; then
              echo "✅ Fallback Path Image Found: $image_path"
            fi
          fi

          # Fail if No Image Found
          if [ -z "$image_path" ]; then
            echo "❌ Image File Not Found, Build Failed" >&2
            exit 1
          fi

          echo "✅ Copying Image to AnyKernel3 and Final-Image-Find"
          cp "$image_path" ./AnyKernel3/Image
          cp "$image_path" kernel_workspace/kernel_platform/out/Final-Image-Find/Image

      - name: Patch Linux & Replace Image
        if: ${{ github.event.inputs.KPM == 'KPM' }}
        run: |
          set -euo pipefail

          PATCH_DIR="${GITHUB_WORKSPACE}/kernel_workspace/SukiSU_patch/kpm"
          OUT_DIR="${GITHUB_WORKSPACE}/kernel_workspace/kernel_platform/out/Final-Image-Find"

          echo ">> Entering Final-Image-Find Directory"
          cd "${OUT_DIR}"

          echo ">> Copying Patch Linux Script and Making it Executable"
          cp "${PATCH_DIR}/patch_linux" .
          chmod +x patch_linux

          echo ">> Applying Linux Patch"
          ./patch_linux

          echo ">> Replacing Image with Patched Version"
          rm -f Image
          mv oImage Image

          echo ">> Copying Patched Image Back to AnyKernel3"
          cp Image "${GITHUB_WORKSPACE}/AnyKernel3/Image"

          echo "✅ Linux Patch Applied and Image Replaced Successfully"

   
