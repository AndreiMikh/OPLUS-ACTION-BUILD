      - name: Load Ccache
        if: ${{ github.event.inputs.BUILD_NOCCACHE == 'false' }}
        uses: actions/cache@v4
        with:
          path: ${{ env.CCACHE_DIR }}
          key: >
            ccache-${{ runner.os }}-${{ github.ref_name }}-
            ${{ github.event.inputs.FILE }}-${{ env.BUILD_METHOD }}-
            ${{ github.event.inputs.FAST_BUILD == 'true' && 'alpha' || 'beta' }}-16.2

      - name: Setup Compiler Cache
        if: ${{ github.event.inputs.BUILD_NOCCACHE == 'false' }}
        run: |
          INIT_FLAG="${{ env.CCACHE_DIR }}/.ccache_initialized"

          if command -v ccache >/dev/null 2>&1; then
            if [ ! -f "$INIT_FLAG" ]; then
              echo "Setting up Compiler Cache at ${{ env.CCACHE_DIR }}..."
              mkdir -p "${{ env.CCACHE_DIR }}"
              ccache -M ${{ env.CCACHE_MAXSIZE }}
              touch "$INIT_FLAG"
              echo "Compiler Cache Setup Complete"
            else
              echo "Compiler Cache Already Initialized, Skipping"
            fi
          else
            echo "Ccache Not Installed, Skipping Compiler Cache Setup"
          fi

          # Display Current Ccache sStatistics
          ccache -s

      - name: Setup Google Repository Tool
        run: |
          echo "Downloading Google Repository Tool..."
          curl -sSL https://storage.googleapis.com/git-repo-downloads/repo -o ~/repo
          chmod +x ~/repo
          sudo mv ~/repo /usr/local/bin/repo
          echo "Google Repository Tool Installed Successfully"

      - name: Initialize & Sync Repository
        env:
          FILE: ${{ github.event.inputs.FILE }}
        run: |
          echo "Creating Kernel Workspace..."
          mkdir -p kernel_workspace && cd kernel_workspace

          echo "Setting up Manifest Directory..."
          mkdir -p .repo/manifests
          cp "$GITHUB_WORKSPACE/.repo/manifests_fallback/${FILE}.xml" ".repo/manifests/${FILE}.xml"

          BASE_URL="https://github.com/${MANIFEST_REPO}/${MANIFEST_REPO_NAME}.git"
          echo "Initializing repository using $MANIFEST_REPO/$MANIFEST_REPO_NAME ($MANIFEST_BRANCH)..."
          repo init -u "$BASE_URL" -b "$MANIFEST_BRANCH" -m "${FILE}.xml" --depth=1 --no-clone-bundle --no-tags

          echo "Syncing Repository..."
          repo sync -c -j$(nproc) --no-clone-bundle --no-tags --force-sync

          echo "Cleaning up BUILD.bazel Files & Protected Exports..."
          for dir in kernel_platform/common kernel_platform/msm-kernel; do
            if [ -e "$dir/BUILD.bazel" ]; then
              sed -i '/^[[:space:]]*"protected_exports_list"[[:space:]]*:[[:space:]]*"android\/abi_gki_protected_exports_aarch64",$/d' "$dir/BUILD.bazel"
            fi
            rm -f "$dir/android/abi_gki_protected_exports_"* 2>/dev/null || echo "No protected exports in $dir"
          done

          echo "Repository Initialization & Sync Complete"

      - name: Kernel Version Setup
        run: |
          cd kernel_workspace/kernel_platform

          echo "Determining Android and Kernel Branch Versions..."
          BRANCH=""
          for f in ./common/build.config.constants ./common/build.config.common; do
            [ -f "$f" ] && BRANCH=$(grep -m1 '^BRANCH=' "$f" | cut -d= -f2) && [ -n "$BRANCH" ] && break
          done

          if [[ -z "$BRANCH" && -n "$PATH_2" ]]; then
            BRANCH=$(sed -n '2p' "./$PATH_2/android/ACK_SHA" | awk -F'-' '{print $1"-"$2}')
          fi

          if [ -n "$BRANCH" ]; then
            echo "KANDROID_VERSION=${BRANCH%-*}" >> $GITHUB_ENV
            echo "KERNEL_VERSION=${BRANCH#*-}" >> $GITHUB_ENV
            echo "Branch found: $BRANCH"
          else
            echo "No Branch Found in Build Config or ACK_SHA."
          fi

          echo "Reading Original Kernel Version..."
          ORIG_VERSION=$(awk '/^VERSION =/ {v=$3} /^PATCHLEVEL =/ {p=$3} /^SUBLEVEL =/ {s=$3} END {print v"."p"."s}' ./common/Makefile)

          SUBLEVEL_INPUT="${{ github.event.inputs.SUBLEVEL }}"
          if [ -n "$SUBLEVEL_INPUT" ]; then
            echo "Updating Sublevel to: $SUBLEVEL_INPUT"
            sed -i "s/^\(SUBLEVEL[[:space:]]*=[[:space:]]*\).*/\1$SUBLEVEL_INPUT/" ./common/Makefile
          else
            echo "No Sublevel Input Provided; Keeping Default"
          fi

          NEW_VERSION=$(awk '/^VERSION =/ {v=$3} /^PATCHLEVEL =/ {p=$3} /^SUBLEVEL =/ {s=$3} END {print v"."p"."s}' ./common/Makefile)

          if [ "$ORIG_VERSION" != "$NEW_VERSION" ]; then
            echo "Kernel Version Changed: $ORIG_VERSION -> $NEW_VERSION"
            echo "TKERNEL_VERSION=$NEW_VERSION" >> $GITHUB_ENV
          else
            echo "Kernel Version Unchanged: $ORIG_VERSION"
            echo "TKERNEL_VERSION=$ORIG_VERSION" >> $GITHUB_ENV
          fi

          KV_TMP="${BRANCH#*-}"
          echo "KV1=$(echo "$KV_TMP" | cut -d. -f1)" >> $GITHUB_ENV
          echo "KV2=$(echo "$KV_TMP" | tr -d '.')" >> $GITHUB_ENV
          echo "KV3=$(echo "$NEW_VERSION" | tr -d '.')" >> $GITHUB_ENV

      - name: Rust Compiler Setup
        run: |
          cd kernel_workspace/kernel_platform

          echo "Checking Rust Compiler Version..."
          RUSTC_VERSION=""
          if [[ -f ./common/build.config.constants ]]; then
            RUSTC_VERSION=$(grep '^RUSTC_VERSION=' ./common/build.config.constants | cut -d'=' -f2 || true)
          fi

          if [[ -n "$RUSTC_VERSION" ]]; then
            echo "Found Rustc Version: $RUSTC_VERSION"
            echo "RUSTC_VERSION=$RUSTC_VERSION" >> $GITHUB_ENV
            echo "ENABLE_RUST=true" >> $GITHUB_ENV
          else
            echo "Rustc Version Not Found; Rust Compilation Disabled"
            echo "ENABLE_RUST=false" >> $GITHUB_ENV
          fi

      - name: Inject Custom Kernel Version Suffix
        if: ${{ github.event.inputs.SUFFIX != '' }}
        run: |
          cd kernel_workspace

          SUFFIX="${{ github.event.inputs.SUFFIX }}"
          KANDROID_VERSION="${{ env.KANDROID_VERSION }}"
          FAST_BUILD="${{ github.event.inputs.FAST_BUILD }}"

          echo "Injecting Custom Kernel Suffix: $SUFFIX"

          for path in \
            kernel_platform/common/scripts/setlocalversion \
            kernel_platform/msm-kernel/scripts/setlocalversion \
            kernel_platform/external/dtc/scripts/setlocalversion; do

            [ -f "$path" ] || continue
            echo "Processing: $path"

            # Remove -dirty tags
            sed -i 's/ -dirty//g' "$path"
            sed -i '$i res=$(echo "$res" | sed '\''s/-dirty//g'\'')' "$path"

            if grep -q 'KERNELVERSION.*scm_version' "$path"; then
              echo "New SetLocalVersion Format Detected"
              sed -i "s|echo \"\${KERNELVERSION}.*scm_version}\"|echo \"\${KERNELVERSION}-${KANDROID_VERSION}-${SUFFIX}\"|" "$path"

            elif grep -q 'echo "\$res"' "$path"; then
              echo "Old SetLocalVersion Format Detected"

              if [ "$FAST_BUILD" = "true" ]; then
                echo "Fast Build Enabled: Setting Static Res Value"
                sed -i "s/^res=.*/res=\"-${KANDROID_VERSION}-${SUFFIX}\"/" "$path"
              else
                echo "Standard Build: Dynamically Injecting Suffix"
                if [[ -f ./kernel_platform/build_with_bazel.py ]]; then
                  echo "Note: Using Bazel may Limit Special Characters, Adjust Script if Compilation Fails"
                fi
                tac "$path" | sed "0,/echo \"\\\$res\"/s//res=\\\$(echo \\\$res | cut -d- -f1-2)-${SUFFIX}; echo \"\\\$res\";/" | tac > "$path.tmp"
                mv "$path.tmp" "$path"
              fi

            else
              echo "Unknown Format: Appending Suffix Manually"
              echo "echo \"\$res-${SUFFIX}\"" >> "$path"
            fi

            chmod +x "$path"
          done

          echo "Committing Suffix Modifications..."
          git add -A
          git commit -m "Inject custom kernel suffix and remove -dirty tags"

      - name: Apply Auto-Generated Kernel Suffix
        if: ${{ github.event.inputs.SUFFIX == '' }}
        run: |
          cd kernel_workspace

          KANDROID_VERSION="${{ env.KANDROID_VERSION }}"
          FAST_BUILD="${{ github.event.inputs.FAST_BUILD }}"

          echo "Generating Random Kernel Suffix..."
          RANDOM_DIGIT=$(od -An -N1 -tu1 < /dev/urandom | tr -d '[:space:]' | awk '{print $1 % 11}')
          RANDOM_HASH=$(od -An -N7 -tx1 /dev/urandom | tr -d ' \n')
          AUTO_SUFFIX="${RANDOM_DIGIT}-o-g${RANDOM_HASH}"

          echo "Random Suffix Generated: $AUTO_SUFFIX"

          for path in \
            kernel_platform/common/scripts/setlocalversion \
            kernel_platform/msm-kernel/scripts/setlocalversion \
            kernel_platform/external/dtc/scripts/setlocalversion; do

            [ -f "$path" ] || continue
            echo "Processing: $path"

            # Remove -dirty markers
            sed -i 's/ -dirty//g' "$path"
            sed -i '$i res=$(echo "$res" | sed '\''s/-dirty//g'\'')' "$path"

            if grep -q 'KERNELVERSION.*scm_version' "$path"; then
              echo "New SetLocalVersion Format Detected"
              sed -i "s|echo \"\${KERNELVERSION}.*scm_version}\"|echo \"\${KERNELVERSION}-${KANDROID_VERSION}-${AUTO_SUFFIX}\"|" "$path"

            elif grep -q 'echo "\$res"' "$path"; then
              echo "Old SetLocalVersion Format Detected"

              if [ "$FAST_BUILD" = "true" ]; then
                echo "Fast Build: Using Static Res with Random Suffix"
                sed -i "s/^res=.*/res=\"-${KANDROID_VERSION}-${AUTO_SUFFIX}\"/" "$path"
              else
                echo "Standard Build: Injecting Random Suffix Dynamically"
                tac "$path" | sed "0,/echo \"\\\$res\"/s//res=\\\$(echo \\\$res | cut -d- -f1-2)-${AUTO_SUFFIX}; echo \"\\\$res\";/" | tac > "$path.tmp"
                mv "$path.tmp" "$path"
              fi

            else
              echo "Unknown Format: Appending Random Suffix Manually"
              echo "echo \"\$res-${AUTO_SUFFIX}\"" >> "$path"
            fi

            chmod +x "$path"
          done

          echo "Committing changes with Auto-Generated Kernel Suffix..."
          git add -A
          git commit -m "Apply auto-generated kernel suffix & remove -dirty markers"


################################################################################################################
      - name: Extract Manifest Information
        id: extract_info
        env:
          FILE: ${{ github.event.inputs.FILE }}
          DYNAMIC_REPO_INPUT: ${{ github.event.inputs.DYNAMIC_REPO }}
        run: |
          set -e
          cd "$GITHUB_WORKSPACE"

          echo "Extract Manifest"

          # Normalize File Name
          if [[ "$FILE" =~ ^(.+)_([a-zA-Z])$ ]]; then
            FILE_CONF="${BASH_REMATCH[1]}"
          else
            FILE_CONF="$FILE"
          fi
          
          FILE_BASE=$(echo "$FILE_CONF" | sed -E '
            s/_aosp/(AOSP)/g;
            s/_([a-zA-Z0-9])/\U\1/g;
            s/^oneplus/OnePlus/;
            s/^realme/RealME/;
            s/^oppo/OPPO/
          ')

          mkdir -p ".repo/manifests_fallback"
          XML_PATH=".repo/manifests_fallback/${FILE}.xml"
          README_PATH=".repo/manifests_fallback/README.md"

          echo "FILE=$FILE"
          echo "FILE_CONF=$FILE_CONF"
          echo "FILE_BASE=$FILE_BASE"

          {
            echo "FILE_CONF=$FILE_CONF"
            echo "FILE_BASE=$FILE_BASE"
            } >> "$GITHUB_ENV"
          
            # Repository Priority:
            # 1. OnePlusOSS/kernel_manifest
            # 2. OnePlusOSS/Kernel_Manifest_Appendix
            # 3. User Defined Dynamic Repo
          
            declare -A REPOS
          
            REPOS["OnePlusOSS"]="OnePlusOSS|kernel_manifest"
            REPOS["Appendix"]="OnePlusOSS|Kernel_Manifest_Appendix"
          
            # Only Register Dynamic Repository if Input is Not Empty
            if [[ -n "$DYNAMIC_REPO_INPUT" ]]; then
              # Remove https://github.com/ if User Pasted full URL
              DYNAMIC_REPO_INPUT="${DYNAMIC_REPO_INPUT#https://github.com/}"
              DYNAMIC_REPO_INPUT="${DYNAMIC_REPO_INPUT%/}"
              
              if [[ "$DYNAMIC_REPO_INPUT" =~ ^[^/]+/[^/]+$ ]]; then
                echo "Dynamic Repository Detected: $DYNAMIC_REPO_INPUT"
                REPOS["Dynamic"]="${DYNAMIC_REPO_INPUT}|kernel_manifest"
              else
                echo "WARNING: Invalid Dynamic Repository Format"
                echo "Expected: OWNER/REPO"
                echo "Provided: $DYNAMIC_REPO_INPUT"
                echo "Skipping Dynamic Repository Instead of Failing"
              fi
            fi
                        
            FOUND_REPO=""
            FOUND_REPO_NAME=""
            FOUND_BRANCH=""

            check_repo() {
              local ENTRY="$1"
              [[ -z "$ENTRY" ]] && return 1
                     
              local OWNER=${ENTRY%%|*}
              local REPO_NAME=${ENTRY##*|}

              echo ""
              echo ">>> Checking ${OWNER}/${REPO_NAME}"
            
            local API_URL="https://api.github.com/repos/${OWNER}/${REPO_NAME}"

            # Fetch Branches Safely with GitHub Token
            local BRANCHES
            BRANCHES=$(curl -fsSL -H "Authorization: token $GH_TOKEN" "${API_URL}/branches" \
              | jq -r '.[]?.name' 2>/dev/null || true)

            if [[ -z "$BRANCHES" ]]; then
              echo "Failed to Retrieve Branches for ${OWNER}/${REPO_NAME}"
              return 1
            fi
            
            for BRANCH in $BRANCHES; do
              echo "  → Trying Branch: $BRANCH"
              
              XML_URL="https://raw.githubusercontent.com/${OWNER}/${REPO_NAME}/${BRANCH}/${FILE}.xml"
              README_URL="https://raw.githubusercontent.com/${OWNER}/${REPO_NAME}/${BRANCH}/README.md"

              if curl -sf -H "Authorization: token $GH_TOKEN" --head "$XML_URL" >/dev/null; then
                echo "Found ${FILE}.xml in ${OWNER}/${REPO_NAME} (Branch: $BRANCH)"

                # Download XML and README using GitHub Token
                curl -fsSL -H "Authorization: token $GH_TOKEN" -o "$XML_PATH" "$XML_URL"
                curl -fsSL -H "Authorization: token $GH_TOKEN" -o "$README_PATH" "$README_URL" || true

                FOUND_REPO="$OWNER"
                FOUND_REPO_NAME="$REPO_NAME"
                FOUND_BRANCH="$BRANCH"

                return 0
              fi
            done

            echo "Not Found in ${OWNER}/${REPO_NAME}"
            return 1
          }

          # Ordered Search
          for key in OnePlusOSS Appendix Dynamic; do
            if [[ -n "${REPOS[$key]}" ]]; then
              if check_repo "${REPOS[$key]}"; then
                break
              fi
            fi
          done

          # Final Validation
          if [[ -z "$FOUND_REPO" || ! -s "$XML_PATH" ]]; then
            echo ""
            echo "ERROR: ${FILE}.xml Not Found in Any Configured Repository"
            exit 9
          fi

          echo ""
          echo "============= Manifest Located ============="
          echo "Repository : ${FOUND_REPO}/${FOUND_REPO_NAME}"
          echo "Branch     : ${FOUND_BRANCH}"
          echo "============================================"

          {
            echo "MANIFEST_REPO=$FOUND_REPO"
            echo "MANIFEST_REPO_NAME=$FOUND_REPO_NAME"
            echo "MANIFEST_BRANCH=$FOUND_BRANCH"
          } >> "$GITHUB_ENV"
                 
          # Parse Revision String

          echo "Parsing Manifest"

          REVISION=$(grep -oP '<project[^>]+revision="\K[^"]+' "$XML_PATH" | head -n1 || true)

          if [[ -z "${REVISION:-}" ]]; then
            echo "ERROR: No revision string found in XML"
            exit 1
          fi

          echo "REVISION=$REVISION"
          echo "Parsing CPU & Android Version..."

          # Extract CPU
          CPU=$(echo "$REVISION" | sed -E 's#^(oneplus|realme|oppo)/([^_]+).*#\2#')

          # Extract Android Version (e.g. 13.0 or 14.0.1)
          ANDROID_VERSION=$(echo "$REVISION" | grep -oE '[0-9]{1,2}\.[0-9]{1,2}(\.[0-9]{1,2})?' | head -n1 || true)

          if [[ -z "$CPU" || -z "$ANDROID_VERSION" ]]; then
            echo "ERROR: Failed to extract CPU or Android version"
            exit 1
          fi

          ANDROID_SHORT_VERSION="${ANDROID_VERSION%%.*}"

          echo "CPU=$CPU"
          echo "ANDROID_VERSION=$ANDROID_VERSION"
          echo "ANDROID_SHORT_VERSION=$ANDROID_SHORT_VERSION"

          {
            echo "CPU=$CPU"
            echo "ANDROID_VERSION=$ANDROID_VERSION"
            echo "ANDROID_SHORT_VERSION=$ANDROID_SHORT_VERSION"
          } >> "$GITHUB_ENV"

          # Parse README to Obtain CPUD & Build Method
          echo "Parsing README"

          if [[ -s "$README_PATH" ]]; then
            BUILD_LINE=$(grep -m1 'oplus_build_kernel.sh' "$README_PATH" || true)

            if [[ -n "$BUILD_LINE" ]]; then
              # More reliable extraction: pull last two arguments
              CPUD=$(awk '{print $(NF-1)}' <<< "$BUILD_LINE")
              BUILD_METHOD=$(awk '{print $NF}' <<< "$BUILD_LINE")

              echo "CPUD=$CPUD"
              echo "BUILD_METHOD=$BUILD_METHOD"

              {
                echo "CPUD=$CPUD"
                echo "BUILD_METHOD=$BUILD_METHOD"
              } >> "$GITHUB_ENV"
            else
              echo "WARNING: Build command not found in README.md"
            fi
          else
            echo "WARNING: README missing or empty"
          fi

          # Parse XML to Obtain PATH_2
          echo "Searching PATH_2"

          PATH_2=""

          if [[ "$CPU" == sm* ]]; then
            COUNT_MATCH=0

            while IFS= read -r LINE; do
              REV=$(grep -oP 'revision="\K[^"]+' <<< "$LINE" || true)
              PATH_VAL=$(grep -oP 'path="\K[^"]+' <<< "$LINE" || true)

              [[ -z "$REV" || -z "$PATH_VAL" ]] && continue

              if [[ "$REV" =~ ^(oneplus|oppo)/ ]] || [[ "$REV" == "master" ]]; then
                COUNT_MATCH=$((COUNT_MATCH + 1))

                if [[ $COUNT_MATCH -eq 2 ]]; then
                  PATH_2="${PATH_VAL#kernel_platform/}"
                  break
                fi
              fi
            done < <(grep "<project " "$XML_PATH" || true)
          fi

          if [[ -n "$PATH_2" ]]; then
            echo "PATH_2=$PATH_2"
            echo "PATH_2=$PATH_2" >> "$GITHUB_ENV"
          else
            echo "No valid PATH_2 found (may not apply to this device)"
          fi

          # Export Combined Output Value
          echo "value=${FILE_BASE}_Android${ANDROID_VERSION}" >> "$GITHUB_OUTPUT"

          echo "Manifest Parsing Complete"    
          
      - name: Debug – Show Selected Inputs
        shell: bash
        run: |
          set -euo pipefail

          echo "--- DEBUG INPUTS ---"

           # Helper: Print Unicode Codepoints
           print_unicode() {
             local LABEL="$1"
             local VALUE="$2"

             echo -n "$LABEL Unicode: "

             python3 <<EOF
          import unicodedata
          value = """$VALUE"""
          output = []
          for c in value:
              code = f"U+{ord(c):04X}"
              if c.isspace() or unicodedata.category(c) == "Cf":
                  output.append(f"\033[31m{code}\033[0m")
              else:
                  output.append(code)
          print(" ".join(output))
          EOF
                echo
              }

              # ENV Variables (Parsed from Manifest)
              
              echo "--- Manifest Parsed Values ---"
              echo "CPU               : ${CPU:-<empty>}"
              echo "CPUD              : ${CPUD:-<empty>}"
              echo "ANDROID_VERSION   : ${ANDROID_VERSION:-<empty>}"
              echo "BUILD_METHOD      : ${BUILD_METHOD:-<empty>}"

              # GitHub Action Inputs
              
              echo "--- GitHub Inputs ---"
              echo "FILE              : ${{ github.event.inputs.FILE }}"
              echo "KPM               : ${{ github.event.inputs.KPM }}"
              echo "MANAGER_SOURCE    : ${{ github.event.inputs.MANAGER_SOURCE }}"
              echo "SUSFS_META        : ${{ github.event.inputs.SUSFS_META }}"
              echo "KSU_META          : ${{ github.event.inputs.KSU_META }}"
              echo "ZRAM              : ${{ github.event.inputs.ZRAM }}"
              echo "BUILD_TIME        : ${{ github.event.inputs.BUILD_TIME }}"
              echo "SUFFIX            : ${{ github.event.inputs.SUFFIX }}"
              echo "LSM               : ${{ github.event.inputs.LSM }}"
              echo "NETFILTER         : ${{ github.event.inputs.NETFILTER }}"
              echo "BBR_ECN           : ${{ github.event.inputs.BBR_ECN }}"
              echo "SUSFS_DEV         : ${{ github.event.inputs.SUSFS_DEV }}"
              echo "FAST_BUILD        : ${{ github.event.inputs.FAST_BUILD }}"
              echo "SCHED             : ${{ github.event.inputs.SCHED }}"
              echo "UNICODE_BYPASS    : ${{ github.event.inputs.UNICODE_BYPASS }}"
              echo "XUS_FIX           : ${{ github.event.inputs.XUS_FIX }}"

              # Unicode Inspection (Whitespace / Hidden Character Detection)

              print_unicode "BUILD_TIME" "${{ github.event.inputs.BUILD_TIME }}"
              print_unicode "SUFFIX" "${{ github.event.inputs.SUFFIX }}"

      #######################################################################################################################

      - name: Setup Required Packages
        uses: awalsh128/cache-apt-pkgs-action@latest
        with:
          packages: |
            python3
            git
            curl
            ccache
            libelf-dev
            build-essential
            flex
            bison
            libssl-dev
            libncurses-dev
            liblz4-tool
            zlib1g-dev
            libxml2-utils
            rsync
            unzip
            gawk
            dos2unix
            kmod
            libdw-dev
            elfutils
          execute_install_scripts: true
      #######################################################################################################################

      - name: Build Kernel (Fast)
        if: ${{ github.event.inputs.FAST_BUILD == 'true' }}
        id: fast_build
        run: |
          cd kernel_workspace/kernel_platform

          # Automatic LLVM IAS Detection 
          if [[ -f ./common/build.config.arm ]] && grep -q '^LLVM_IAS=1' ./common/build.config.arm; then
            USE_LLVM_IAS=true
          else
            USE_LLVM_IAS=false
          fi

          # Locate Clang Prebuilt Bin 
          CLANG_PREBUILT_BIN=""
          for f in ./common/build.config.common ./"$PATH_2"/build.config.common; do
            [[ -f "$f" ]] || continue
            CLANG_PREBUILT_BIN=$(grep '^CLANG_PREBUILT_BIN=' "$f" | cut -d'=' -f2)
            [[ -n "$CLANG_PREBUILT_BIN" ]] && break
          done

          if [[ -z "$CLANG_PREBUILT_BIN" ]]; then
            echo "⚠️ Clang Prebuilt Bin not found; fallback to official build"
            echo "fallback=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # Extract Clang Version
          if [[ "$CLANG_PREBUILT_BIN" =~ (clang-r[0-9a-z]+) ]]; then
            CLANG_VERSION="${BASH_REMATCH[1]}"
          elif [[ -f ./common/build.config.constants ]]; then
            CLANG_VERSION=$(grep '^CLANG_VERSION=' ./common/build.config.constants | cut -d'=' -f2 || true)
          fi

          if [[ -z "$CLANG_VERSION" ]]; then
            echo "⚠️ Cannot detect Clang version; fallback to official build"
            echo "fallback=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # Replace variable in path
          CLANG_PREBUILT_BIN=${CLANG_PREBUILT_BIN/\$\{CLANG_VERSION\}/$CLANG_VERSION}
          CLANG_DIR=$(echo "$CLANG_PREBUILT_BIN" | cut -d'/' -f1)
          CLANG_PATH=$(basename "$(dirname "$CLANG_PREBUILT_BIN")")

          echo "CLANG_VERSION=$CLANG_VERSION"
          echo "CLANG_DIR=$CLANG_DIR"
          echo "CLANG_PATH=$CLANG_PATH"
          echo "USE_LLVM_IAS=$USE_LLVM_IAS"

          # Environment Setup 
          set +u
          source "$GITHUB_WORKSPACE/kernel_workspace/kernel_platform/build/kernel/_setup_env.sh" 2>/dev/null || true
          set -u

          export PATH="$GITHUB_WORKSPACE/kernel_workspace/kernel_platform/$CLANG_PREBUILT_BIN:$PATH"
          export PATH="/usr/lib/ccache:$PATH"
          export HDRINST=:

          if [[ "$ENABLE_RUST" == "true" ]]; then
            export BINDGEN="bindgen"
            export LIBCLANG_PATH="$GITHUB_WORKSPACE/kernel_workspace/kernel_platform/$(dirname "$CLANG_PREBUILT_BIN")/lib"
          fi

          cd ./common

          MAP="-fdebug-prefix-map=${GITHUB_WORKSPACE}=."
          MPMAP="-fmacro-prefix-map=${GITHUB_WORKSPACE}=."
          FPMAP="-ffile-prefix-map=${GITHUB_WORKSPACE}=."

          MAKE_ARGS=(
            LLVM=1
            ARCH=arm64
            CROSS_COMPILE=aarch64-linux-gnu-
            CC="ccache clang"
            HOSTCC="ccache clang"
            LD=ld.lld
            HOSTLD=ld.lld
            PAHOLE=../../prebuilts/kernel-build-tools/linux-x86/bin/pahole
            KCFLAGS+="$MAP $MPMAP $FPMAP"
            KCFLAGS+=-Wno-error
            KCFLAGS+=-D__ANDROID_COMMON_KERNEL__
          )

          [[ "$USE_LLVM_IAS" == "true" ]] && MAKE_ARGS=(LLVM_IAS=1 "${MAKE_ARGS[@]}")
          [[ "$ENABLE_RUST" == "true" ]] && MAKE_ARGS=(RUSTC=../../prebuilts/rust/linux-x86/$RUSTC_VERSION/bin/rustc "${MAKE_ARGS[@]}")

          make O=out "${MAKE_ARGS[@]}" gki_defconfig

          # LTO config based on kernel version
          if [[ "$KERNEL_VERSION" == "5.10" || "$KERNEL_VERSION" == "5.15" ]]; then
            scripts/config --file out/.config -e LTO_CLANG -e LTO_CLANG_THIN -d LTO_CLANG_NONE -d LTO_CLANG_FULL
          elif [[ "$KERNEL_VERSION" == "6.12" ]]; then
            scripts/config --file out/.config -e LTO_CLANG -e LTO_CLANG_NONE -d LTO_CLANG_THIN -d LTO_CLANG_FULL
          fi

          make O=out "${MAKE_ARGS[@]}" olddefconfig
          make -j"$(nproc --all)" O=out "${MAKE_ARGS[@]}"
          ccache -s

      #######################################################################################################################

      - name: Fallback Build (HDRINST + LLVM + lld fix)
        if: ${{ github.event.inputs.FAST_BUILD == 'false' || steps.fast_build.outputs.fallback == 'true' }}
        run: |
          cd kernel_workspace/kernel_platform

          # === Fix HDRINST to avoid install headers error ===
          export HDRINST=:

          # === Ensure Clang + lld are used for host and target ===
          export PATH="$GITHUB_WORKSPACE/kernel_workspace/kernel_platform/prebuilts/clang/host/linux-x86/llvm-rXYZ/bin:$PATH"
          export CC=clang
          export HOSTCC=clang
          export LD=ld.lld
          export HOSTLD=ld.lld

          # Optional: ccache if desired
          export PATH="/usr/lib/ccache:$PATH"

          # === Build kernel in common/out ===
          cd common

          # Remap physical paths to avoid debug file warnings
          MAP="-fdebug-prefix-map=${GITHUB_WORKSPACE}=."
          MPMAP="-fmacro-prefix-map=${GITHUB_WORKSPACE}=."
          FPMAP="-ffile-prefix-map=${GITHUB_WORKSPACE}=."

          MAKE_ARGS=(
            ARCH=arm64
            CROSS_COMPILE=aarch64-linux-gnu-
            CC="$CC"
            HOSTCC="$HOSTCC"
            LD="$LD"
            HOSTLD="$HOSTLD"
            KCFLAGS+="$MAP $MPMAP $FPMAP"
            KCFLAGS+=-Wno-error
            KCFLAGS+=-D__ANDROID_COMMON_KERNEL__
          )

          # Run sub-make safely
          make O=out "${MAKE_ARGS[@]}" gki_defconfig || true
          make -j"$(nproc --all)" O=out "${MAKE_ARGS[@]}" || true

          # Check if Image is generated
          if [ ! -f out/Image ]; then
            echo "❌ Kernel build failed: Image not found" >&2
            exit 1
          fi

          echo "✅ Kernel build completed successfully"
      
      #######################################################################################################################

      - name: Make AnyKernel3
        run: |
          set -euo pipefail

          echo ">> Cloning AnyKernel3 Repository"
          git clone https://github.com/AndreiMikh/AnyKernel3 --depth=1
          rm -rf ./AnyKernel3/.git

          echo ">> Ensuring Final-Image-Find Directory Exists"
          mkdir -p kernel_workspace/kernel_platform/out/Final-Image-Find/

          image_path=""

          # Try to Locate Image in Unified Build Path
          if [ -d "./kernel_workspace/kernel_platform/common/out/" ]; then
            image_path=$(find "./kernel_workspace/kernel_platform/common/out/" -name "Image" | head -n 1)
            if [ -n "$image_path" ]; then
              echo "✅ Unified Path Image Found: $image_path"
            fi
          fi

          # If Not Found, Try Fallback Path
          if [ -z "$image_path" ] && [ -d "./kernel_workspace/kernel_platform/out/" ]; then
            image_path=$(find "./kernel_workspace/kernel_platform/out/" -name "Image" | head -n 1)
            if [ -n "$image_path" ]; then
              echo "✅ Fallback Path Image Found: $image_path"
            fi
          fi

          # Fail if No Image Found
          if [ -z "$image_path" ]; then
            echo "❌ Image File Not Found, Build Failed" >&2
            exit 1
          fi

          echo "✅ Copying Image to AnyKernel3 and Final-Image-Find"
          cp "$image_path" ./AnyKernel3/Image
          cp "$image_path" kernel_workspace/kernel_platform/out/Final-Image-Find/Image

      - name: Patch Linux & Replace Image
        if: ${{ github.event.inputs.KPM == 'KPM' }}
        run: |
          set -euo pipefail

          PATCH_DIR="${GITHUB_WORKSPACE}/kernel_workspace/SukiSU_patch/kpm"
          OUT_DIR="${GITHUB_WORKSPACE}/kernel_workspace/kernel_platform/out/Final-Image-Find"

          echo ">> Entering Final-Image-Find Directory"
          cd "${OUT_DIR}"

          echo ">> Copying Patch Linux Script and Making it Executable"
          cp "${PATCH_DIR}/patch_linux" .
          chmod +x patch_linux

          echo ">> Applying Linux Patch"
          ./patch_linux

          echo ">> Replacing Image with Patched Version"
          rm -f Image
          mv oImage Image

          echo ">> Copying Patched Image Back to AnyKernel3"
          cp Image "${GITHUB_WORKSPACE}/AnyKernel3/Image"

          echo "✅ Linux Patch Applied and Image Replaced Successfully"

   
